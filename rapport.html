<!doctype html>
<html lang="fr">


<head>
	<title> Rapport </title>
	<meta charset = "utf-8"/>
	<link rel="stylesheet" href="styles.css">
	<link rel="stylesheet" href="stylesRapport.css">
</head>

<body>

<h1> Rapport </h1>
	
<h2>Objectifs et motivations du projet</h2>	
<p>Notre projet consiste à recréer sous une différente forme, le jeu « Deviner l’image » en le programmant sur python.
<br>
Nous avons voulu créer différents modes de jeux (thèmes) pour le joueur avec 5 images à deviner par mode. Pour complexifier le jeu, ce dernier proposera d’abord au joueur une image avec un effet « pixelisé » lorsque l’image devient plus difficile à deviner ou en cachant une certaine partie de l’image comme avec les drapeaux.
Pour intégrer au programme des notions étudiées en cours nous avons mis en place dans le programme, un trieur permettant de trier par ordre croissant de score les différents résultats sous forme « nom : score » enregistrés préalablement par le programme à l’issue de chaque partie enregistrée par le joueur.
<br>
Nous avons également souhaité en apprendre davantage sur la programmation dans le langage informatique Python.
</p>

<h2>Organisation du travail en équipe</h2>
<p>Concernant l’organisation du travail durant ce projet, nous avions tout d’abord à notre disposition 6 heures en classe qui nous ont permis de nous concerter sur les objectifs, motivations du projet et son organisation puis de débuter l’écriture du programme.
<br>
Grâce aux outils de Github et Google Drive nous avons pu, avec facilité, nous partager les différentes images que nous allions utiliser ainsi que consulter les différents changements opérés par chacun de nous à part.
<br>
Chaque dimanche, nous nous réunissions également par appel vocal sur Discord pour pouvoir avancer plus rapidement et faciliter les échanges, surtout pour régler les différents problèmes que nous avons pu rencontrer. Ceci était également permis par la fonction de partage d’écran durant un appel.
<br>
Après avoir fini le programme, nous avons tous pu le tester et le décortiquer à la recherche du moindre problème présent pour ainsi pouvoir le corriger.
<br>
Chacun de nous a donc pu participer à l’élaboration du programme ainsi que la rédaction de ce rapport.
</p>
	
<h2>Description des différents éléments du programme</h2>
<img src="capture1.png">
<p>Notre programme commence tout d’abord par l’importation de tous les éléments de la bibliothèque « tkinter » qui nous permettre d’élaborer l’interface graphique du jeu.
<br>
S’en suit l’initialisation à 0 de la variable « score » qui donnera le score du joueur.
<br>
Fonction « Jeu »: 
Il y a ensuite, la définition de la fonction « Jeu » qui est partagée en 5 autres fonctions correspondants au 5 modes de jeux : « Personnages réels », « Personnages fictifs », « Films, séries et jeux », « Villes et drapeaux » et « Logos ».
Elle contient cependant d’abord la création de la fenêtre de début du jeu et choix du mode mais aussi les fonctions « up » et « up2 ».
La fonction « up » permet d’ajouter à la variable « score » la valeur 1.
La fonction « up2 » remplit le même role en ajoutant la valeur 2.
</p>
	
<br>
<br>
	
<img src="capture2.png">
<p>Fonction d’un mode de jeu:
Les 5 fonctions des 5 modes de jeux se ressemblent, nous allons donc nous focaliser sur la première : « Personnages réels ».
La fonction « Personnage réels » appelée « PersosReels » commence par la fermeture de la fenêtre de début de jeu et de choix de mode. Elle contient après une boucle « for » se répétant 5 fois. « i » prend donc les valeurs 1,2,3,4 et finalement 5, ce qui correspond aux 5 images à deviner pour le joueur.
Le programme se répète pour chacune des différentes valeurs de « i ». Étudions alors les instructions lorsque i=1.
Il y a tout d’abord la création de la fenêtre de jeu, la définition de sa taille et son titre. Ensuite on crée la variable « reponse » qui contiendra la réponse saisie par le joueur et on incruste l’image brouillée qui sera à deviner. Il y a ensuite la définition de la fonction « vérification » que nous détaillerons plus tard. Finalement nous avons l’incrustation dans la fenêtre du bouton « valider » qui permet d’exécuter la fonction « vérification ».
<br>
Fonction « vérification »:
La fonction « vérification » permet tout d’abord de vérifier si la saisie du joueur correspond à la solution. Si la vérification est validée et vraie, la fonction « up2 » est appelée et la fenêtre « fenJeu » fermée et il y a le passage à la prochaine image à deviner.
Sinon, il y a la fermeture de la première fenêtre de jeu « fenJeu » et la création d’une seconde nommée « fenJeu1 ». De la même façon on définit son titre, taille, variable contenant la réponse du joueur « reponse1 »,  une saisie pour le joueur et l’incrustation de l’image (non brouillée) . On a ensuite, une fonction « verification1 » et le bouton permettant de valider la réponse saisie par le joueur.
<br>
Fonction « verification1 »:
Cette fonction permet, si l’image n’a pas été devinée en étant brouillée, de vérifier la saisie du joueur lorsque l’image n’a pas été brouillée. La fonction contient une boucle « if » permettant comme pour la fonction « verification » de vérifier si si la saisie correspond à la solution. Si cette condition est validée, on appelle la fonction « up » puis dans tous les cas (si la condition est vérifiée ou non » de fermer la fenêtre « fenJeu1 » et la boucle « for » peut continuer et donc faire deviner la deuxième image.
</p>

<br>
<br>
	
<img src="capture3.png">
<p>Concernant le mode de jeu « Logos », la pixelisation ou flouttage de l’image n’aurait en rien complexifié la devinette pour le joueur. Les boucles « if » sont donc simplement constituées de la création d’une fenêtre « fenJeu », d’une saisie, de l’image et d’un bouton permettant de valider la saisie du joueur. Ce bouton fait appel à la fonction « verification » qui contient une boucle « if » . Cette condition vérifie si la saisie du joueur correspond à la solution de l’image. Si elle est validée, on fait appel à la fonction « up », et dans tous les cas, on finit par fermer la fenêtre « fenJeu » pour passer à l’image suivante et la suite du programme.
</p>

<br>
<br>
	
<img src="capture4.png">
<p>Fonction « Jeu » (Suite):
La suite du programme est constituée de la suite de la fonction « Jeu ». On a le texte affiché sur le menu de départ et de choix de mode de jeu puis les 5 boutons correspondants aux 5 modes de jeu. On a ensuite la définition de la fonction « menuFin ».
<br>
Fonction « menuFin »:
Cette fonction débute par la création d’une fenêtre « fenFin », la définition de son titre et taille puis l’affichage d’un texte indiquant à l’utilisateur son score et demande au joueur s’il veut, ou non, sauvegarder sa partie. Il y a ensuite la fonction « ajoutScore »  puis « rejouer » et finalement deux boutons permettant au joueur de faire son choix concernant la sauvegarde, ou non, de son score. S’il choisit de ne pas sauvegarder, la fenêtre  « fenFin » est fermée et le programme s’arrête. Sinon, il y a appel de la fonction « ajoutScore ».
<br>
Fonction « ajoutScore »:
Cette dernière commence par la fermeture de la fenêtre « fenFin » et la création d’une zutre fenêtre « fenSauvegarde ». Après la définition de sa taille et son score, le texte « Votre nom? » est affiché et la variable « nomSaisi » est créée et enregistrera la saisie du joueur. Un bouton permettant la validation par le joueur de sa saisie est ensuite présente qui appelle la fonction « sauvegarde » préalablement définie.
<br>
Fonction « sauvegarde »: 
Elle fait tout d’abord appel à la fonction « ajouter » avec les données « nomSaisi » et le score du joueur. Finalement, la fenêtre « fenSauvegarde » est fermée.
</p>
	
<br>
<br>

<img src="capture5.png">
<p>Fonction « ajouter »:
La fonction «  ajouter(nom, score ) » permet l’ouverture par le programme du fichier « scores.txt » ,présent dans le même dossier que le programme, en mode écriture.
Il y a ensuite la méthode « .write » qui rajoute une ligne au fichier préalablement ouvert et contenant dans l’ordre, le nom du joueur, « : » entre deux espaces, le score du joueur et finalement un retour à la ligne. On fait finalement appel à la méthode « .close » pour fermer le fichier.
<br>
Fonction « tri »:
Cette fonction permet de trier des ensembles « nom : score » présents dans un tableau dans l’ordre décroissant.
<br>
Fonction « menu »:
Lorsque cette dernière est exécutée, elle fait appel aux fonctions « Jeu » puis « menuFin »
<br>
Pour que le joueur consulte le classement de ses scores il doit saisir trier()
</p>

<h2>Développement théorique de la fonction "trier"</h2>
<p>Preuve de correction : <br>
La fonction « trier » crée d’abord un tableau « t » et ouvre le fichier « scores.txt » en mode lecture. Il y a ensuite une boucle « for » se répétant à chaque ligne du fichier et ajoutant chaque ligne a une valeur dans le tableau sous la forme « nom : score ». On ferme le fichier finalement.
La fonction fais ensuite appel à la fonction « tri » et va afficher au joueur « Classement des scores », un saut a la ligne puis chaque ligne du tableau rangé avec un saut à la ligne à chaque fois.
</p>

<h2>Sitographie</h2>
<p><a href="sitographie.html"> La consulter</a></p>

<h2>Accueil & Projet</h2>
<ul class="special">
	<li><a href="index.html"> Page d'accueil</a></li>
	<li><a href="projet.html"> Mon projet</a></li>
</ul>

</body>
